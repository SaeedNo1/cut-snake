<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜çº§è´ªåƒè›‡å¤§æˆ˜</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            background: #000;
        }
        .info {
            color: white;
            margin: 10px 0;
            font-size: 18px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        .status {
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            margin: 10px 0;
        }
        .controls {
            color: white;
            margin-top: 10px;
            font-size: 14px;
        }
        .boss-warning {
            color: #FF4444;
            font-size: 24px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="color: white; margin-top: 0;">ğŸ é«˜çº§è´ªåƒè›‡å¤§æˆ˜ ğŸ</h1>
        <div class="status" id="status">å‡†å¤‡å¼€å§‹ - ä½¿ç”¨ WASD æˆ–æ–¹å‘é”®æ§åˆ¶</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="info">
            <div>ä½ çš„é•¿åº¦: <span id="playerLength">1</span></div>
            <div>æ™®é€šå¯¹æ‰‹: <span id="normalEnemies">0</span></div>
            <div>BOSSçŠ¶æ€: <span id="bossStatus">æœªå‡ºç°</span></div>
            <div>å›åˆ: <span id="round">1</span></div>
        </div>
        <div class="controls">
            ä½¿ç”¨ WASD æˆ–æ–¹å‘é”®æ§åˆ¶ä½ çš„è›‡ç§»åŠ¨<br>
            ğŸ”´ æ™®é€šå¯¹æ‰‹ | âš« BOSS | ğŸŸ¡ é£Ÿç‰© | ğŸŸ¢ ä½ çš„è›‡
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const playerLengthDiv = document.getElementById('playerLength');
        const normalEnemiesDiv = document.getElementById('normalEnemies');
        const bossStatusDiv = document.getElementById('bossStatus');
        const roundDiv = document.getElementById('round');

        // æ¸¸æˆé…ç½®
        const GRID_SIZE = 20;
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const GRID_WIDTH = CANVAS_WIDTH / GRID_SIZE;
        const GRID_HEIGHT = CANVAS_HEIGHT / GRID_SIZE;

        // æ¸¸æˆçŠ¶æ€
        let gameRunning = false;
        let gameLoop;
        let round = 1;
        let bossAppeared = false;
        let bossDefeated = false;

        // æ–¹å‘
        const DIRECTIONS = {
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        // è›‡ç±»
        class Snake {
            constructor(x, y, color, isPlayer = false, isBoss = false) {
                this.body = [{ x, y }];
                this.direction = DIRECTIONS.RIGHT;
                this.color = color;
                this.isPlayer = isPlayer;
                this.isBoss = isBoss;
                this.alive = true;
                this.lastDirection = DIRECTIONS.RIGHT;
                this.grow = false;
                
                // è®¾ç½®åˆå§‹é•¿åº¦
                if (isPlayer) {
                    // ç©å®¶åˆå§‹é•¿åº¦ä¸º3
                    for (let i = 1; i < 3; i++) {
                        this.body.push({ x: x - i, y: y });
                    }
                } else {
                    // AIè›‡åˆå§‹é•¿åº¦ä¸º2
                    for (let i = 1; i < 2; i++) {
                        this.body.push({ x: x - i, y: y });
                    }
                }
            }

            move() {
                if (!this.alive) return;

                const head = { ...this.body[0] };
                head.x += this.direction.x;
                head.y += this.direction.y;

                // è¾¹ç•Œæ£€æµ‹
                if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
                    this.die();
                    return;
                }

                // è‡ªèº«ç¢°æ’æ£€æµ‹
                if (this.checkSelfCollision(head)) {
                    if (!this.isPlayer) {
                        this.turnIntoFood();
                    } else {
                        this.die();
                    }
                    return;
                }

                // ä¸å…¶ä»–è›‡çš„ç¢°æ’æ£€æµ‹
                if (this.checkOtherSnakeCollision(head)) {
                    if (!this.isPlayer) {
                        this.turnIntoFood();
                    } else {
                        this.die();
                    }
                    return;
                }

                this.body.unshift(head);

                // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
                let ateFood = false;
                for (let i = foods.length - 1; i >= 0; i--) {
                    if (head.x === foods[i].x && head.y === foods[i].y) {
                        foods.splice(i, 1);
                        ateFood = true;
                        break;
                    }
                }

                if (!ateFood) {
                    this.body.pop();
                } else {
                    this.grow = true;
                }

                this.lastDirection = { ...this.direction };
            }

            checkSelfCollision(head) {
                return this.body.some(segment => segment.x === head.x && segment.y === head.y);
            }

            checkOtherSnakeCollision(head) {
                for (let snake of otherSnakes) {
                    if (snake.alive && snake !== this) {
                        if (snake.body.some(segment => segment.x === head.x && segment.y === head.y)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            turnIntoFood() {
                if (this.isPlayer) {
                    gameOver();
                    return;
                }
                
                const head = this.body[0];
                foods.push({ x: head.x, y: head.y, type: 'enemy', color: '#FFD700' });
                this.alive = false;
                
                const index = otherSnakes.indexOf(this);
                if (index > -1) {
                    otherSnakes.splice(index, 1);
                }
                
                updateUI();
            }

            die() {
                this.alive = false;
                if (this.isPlayer) {
                    gameOver();
                } else {
                    const head = this.body[0];
                    foods.push({ x: head.x, y: head.y, type: 'enemy', color: '#FFD700' });
                    
                    const index = otherSnakes.indexOf(this);
                    if (index > -1) {
                        otherSnakes.splice(index, 1);
                    }
                }
                updateUI();
            }

            changeDirection(newDirection) {
                if (!this.alive) return;
                
                // ä¿®å¤è½¬å‘é€»è¾‘ - ç°åœ¨å¯ä»¥æ­£å¸¸å·¦è½¬ã€å³è½¬
                const opposites = {
                    [DIRECTIONS.UP]: DIRECTIONS.DOWN,
                    [DIRECTIONS.DOWN]: DIRECTIONS.UP,
                    [DIRECTIONS.LEFT]: DIRECTIONS.RIGHT,
                    [DIRECTIONS.RIGHT]: DIRECTIONS.LEFT
                };

                if (newDirection !== opposites[this.direction]) {
                    this.direction = newDirection;
                }
            }

            draw() {
                if (!this.alive) return;

                this.body.forEach((segment, index) => {
                    // ç»˜åˆ¶åœ†å½¢è›‡èº«
                    ctx.beginPath();
                    ctx.arc(
                        segment.x * GRID_SIZE + GRID_SIZE / 2,
                        segment.y * GRID_SIZE + GRID_SIZE / 2,
                        GRID_SIZE / 2 - 2,
                        0,
                        2 * Math.PI
                    );
                    ctx.fillStyle = this.color;
                    
                    // å¤´éƒ¨é¢œè‰²ç¨å¾®äº®ä¸€ç‚¹
                    if (index === 0) {
                        const brightColor = this.adjustBrightness(this.color, 30);
                        ctx.fillStyle = brightColor;
                    }
                    
                    ctx.fill();
                    
                    // ç»˜åˆ¶çœ¼ç›ï¼ˆä»…å¤´éƒ¨ï¼‰
                    if (index === 0 && (this.isPlayer || this.isBoss)) {
                        this.drawEyes(segment);
                    }
                });
            }

            drawEyes(segment) {
                ctx.fillStyle = 'white';
                const eyeSize = 3;
                const eyeOffset = 5;
                
                if (this.direction.x === 1) { // å‘å³
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, segment.y * GRID_SIZE + 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, segment.y * GRID_SIZE + GRID_SIZE - 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (this.direction.x === -1) { // å‘å·¦
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + 5, segment.y * GRID_SIZE + 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + 5, segment.y * GRID_SIZE + GRID_SIZE - 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (this.direction.y === -1) { // å‘ä¸Š
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + 5, segment.y * GRID_SIZE + 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - 5, segment.y * GRID_SIZE + 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (this.direction.y === 1) { // å‘ä¸‹
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + 5, segment.y * GRID_SIZE + GRID_SIZE - 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - 5, segment.y * GRID_SIZE + GRID_SIZE - 5, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            adjustBrightness(color, amount) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * amount);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }

        // æ¸¸æˆå¯¹è±¡
        let player;
        let otherSnakes = [];
        let foods = [];

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || !player.alive) return;

            switch (e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    player.changeDirection(DIRECTIONS.UP);
                    break;
                case 's':
                case 'arrowdown':
                    player.changeDirection(DIRECTIONS.DOWN);
                    break;
                case 'a':
                case 'arrowleft':
                    player.changeDirection(DIRECTIONS.LEFT);
                    break;
                case 'd':
                case 'arrowright':
                    player.changeDirection(DIRECTIONS.RIGHT);
                    break;
            }
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameRunning = true;
            
            // åˆ›å»ºç©å®¶ï¼ˆåˆå§‹é•¿åº¦3ï¼‰
            player = new Snake(Math.floor(GRID_WIDTH / 2), Math.floor(GRID_HEIGHT / 2), '#00FF00', true);
            
            // æ¸…ç©ºå…¶ä»–è›‡å’Œé£Ÿç‰©
            otherSnakes = [];
            foods = [];
            
            round = 1;
            bossAppeared = false;
            bossDefeated = false;
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop = setInterval(update, 150);
            updateUI();
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            if (!gameRunning) return;

            // ç§»åŠ¨æ‰€æœ‰è›‡
            player.move();
            otherSnakes.forEach(snake => snake.move());

            // AI æ§åˆ¶å…¶ä»–è›‡
            otherSnakes.forEach(snake => {
                if (snake.alive) {
                    aiControl(snake);
                }
            });

            // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
            checkGameStatus();

            // ç»˜åˆ¶
            draw();

            // æ›´æ–°UI
            updateUI();
        }

        // AI æ§åˆ¶
        function aiControl(snake) {
            if (!snake.alive) return;

            const head = snake.body[0];
            let newDirection = snake.direction;

            // å¯»æ‰¾æœ€è¿‘çš„ç›®æ ‡
            let target = findNearestTarget(snake);

            if (target) {
                newDirection = getDirectionTowards(snake, target);
            } else {
                // éšæœºç§»åŠ¨ï¼Œé¿å…æ’å¢™å’Œå…¶ä»–è›‡
                newDirection = getRandomSafeDirection(snake);
            }

            snake.changeDirection(newDirection);
        }

        // å¯»æ‰¾æœ€è¿‘ç›®æ ‡
        function findNearestTarget(snake) {
            let nearest = null;
            let minDistance = Infinity;

            // å¯»æ‰¾ç©å®¶
            const playerHead = player.body[0];
            const playerDistance = Math.abs(playerHead.x - snake.body[0].x) + Math.abs(playerHead.y - snake.body[0].y);
            if (playerDistance < minDistance) {
                minDistance = playerDistance;
                nearest = playerHead;
            }

            // å¯»æ‰¾é£Ÿç‰©
            foods.forEach(food => {
                const distance = Math.abs(food.x - snake.body[0].x) + Math.abs(food.y - snake.body[0].y);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = food;
                }
            });

            return nearest;
        }

        // è·å–æœå‘ç›®æ ‡çš„æ–¹å‘
        function getDirectionTowards(snake, target) {
            const head = snake.body[0];
            const dx = target.x - head.x;
            const dy = target.y - head.y;

            if (Math.abs(dx) > Math.abs(dy)) {
                return dx > 0 ? DIRECTIONS.RIGHT : DIRECTIONS.LEFT;
            } else {
                return dy > 0 ? DIRECTIONS.DOWN : DIRECTIONS.UP;
            }
        }

        // è·å–å®‰å…¨éšæœºæ–¹å‘
        function getRandomSafeDirection(snake) {
            const possibleDirections = [DIRECTIONS.UP, DIRECTIONS.DOWN, DIRECTIONS.LEFT, DIRECTIONS.RIGHT];
            const safeDirections = [];

            possibleDirections.forEach(dir => {
                const newHead = {
                    x: snake.body[0].x + dir.x,
                    y: snake.body[0].y + dir.y
                };

                // æ£€æŸ¥è¾¹ç•Œ
                if (newHead.x < 0 || newHead.x >= GRID_WIDTH || newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
                    return;
                }

                // æ£€æŸ¥è‡ªèº«ç¢°æ’
                if (snake.body.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                    return;
                }

                // æ£€æŸ¥ä¸å…¶ä»–è›‡çš„ç¢°æ’
                let collision = false;
                for (let otherSnake of otherSnakes) {
                    if (otherSnake !== snake && otherSnake.alive) {
                        if (otherSnake.body.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    safeDirections.push(dir);
                }
            });

            if (safeDirections.length > 0) {
                return safeDirections[Math.floor(Math.random() * safeDirections.length)];
            }

            return snake.direction;
        }

        // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
        function checkGameStatus() {
            if (!player.alive) {
                gameOver();
                return;
            }

            const aliveNormalSnakes = otherSnakes.filter(snake => snake.alive && !snake.isBoss);
            if (aliveNormalSnakes.length < 2 && !bossAppeared) {
                addNormalEnemy();
            }

            if (round >= 3 && !bossAppeared && aliveNormalSnakes.length === 0) {
                spawnBoss();
            }

            if (bossAppeared && !bossDefeated) {
                const boss = otherSnakes.find(snake => snake.isBoss && snake.alive);
                if (!boss) {
                    bossDefeated = true;
                    round++;
                    setTimeout(() => {
                        addNormalEnemy();
                    }, 2000);
                }
            }

            const allSnakesDead = otherSnakes.every(snake => !snake.alive) && !player.alive;
            if (allSnakesDead) {
                gameWin();
            }
        }

        // æ·»åŠ æ™®é€šå¯¹æ‰‹
        function addNormalEnemy() {
            let x, y;
            let attempts = 0;
            
            do {
                x = Math.floor(Math.random() * GRID_WIDTH);
                y = Math.floor(Math.random() * GRID_HEIGHT);
                attempts++;
            } while (isPositionOccupied(x, y) && attempts < 50);

            if (attempts < 50) {
                const enemy = new Snake(x, y, '#FF4444');
                otherSnakes.push(enemy);
            }
        }

        // ç”ŸæˆBOSS
        function spawnBoss() {
            bossAppeared = true;
            bossDefeated = false;
            
            let x, y;
            let attempts = 0;
            
            do {
                x = Math.floor(Math.random() * GRID_WIDTH);
                y = Math.floor(Math.random() * GRID_HEIGHT);
                attempts++;
            } while (isPositionOccupied(x, y) && attempts < 50);

            if (attempts < 50) {
                const boss = new Snake(x, y, '#8B0000', false, true);
                boss.isBoss = true;
                otherSnakes.push(boss);
                
                showStatus("âš ï¸ å¼ºå¤§BOSSå‡ºç°ï¼æ¶ˆç­å®ƒç»§ç»­æ¸¸æˆï¼ âš ï¸", 'boss-warning');
            }
        }

        // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨
        function isPositionOccupied(x, y) {
            if (player.body.some(segment => segment.x === x && segment.y === y)) {
                return true;
            }

            for (let snake of otherSnakes) {
                if (snake.alive && snake.body.some(segment => segment.x === x && segment.y === y)) {
                    return true;
                }
            }

            if (foods.some(food => food.x === x && food.y === y)) {
                return true;
            }

            return false;
        }

        // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
        function showStatus(message, className = '') {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + className;
        }

        // æ›´æ–°UI
        function updateUI() {
            playerLengthDiv.textContent = player.body.length;
            const normalEnemies = otherSnakes.filter(snake => snake.alive && !snake.isBoss).length;
            normalEnemiesDiv.textContent = normalEnemies;
            bossStatusDiv.textContent = bossAppeared ? (bossDefeated ? 'å·²å‡»è´¥' : 'æ´»è·ƒä¸­') : 'æœªå‡ºç°';
            roundDiv.textContent = round;
        }

        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // ç»˜åˆ¶é£Ÿç‰©
            foods.forEach(food => {
                ctx.beginPath();
                ctx.arc(
                    food.x * GRID_SIZE + GRID_SIZE / 2,
                    food.y * GRID_SIZE + GRID_SIZE / 2,
                    GRID_SIZE / 2 - 2,
                    0,
                    2 * Math.PI
                );
                ctx.fillStyle = food.color;
                ctx.fill();
            });

            // ç»˜åˆ¶è›‡
            player.draw();
            otherSnakes.forEach(snake => snake.draw());
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            showStatus(`ğŸ’€ æ¸¸æˆç»“æŸï¼ä½ åšæŒäº† ${round} å›åˆ ğŸ’€`, '');
            draw();
        }

        // æ¸¸æˆèƒœåˆ©
        function gameWin() {
            gameRunning = false;
            clearInterval(gameLoop);
            showStatus('ğŸ‰ æ­å–œï¼ä½ æ¶ˆç­äº†æ‰€æœ‰å¯¹æ‰‹ï¼ ğŸ‰', '');
            draw();
        }

        // å¼€å§‹æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
